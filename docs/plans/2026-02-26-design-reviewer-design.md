# Design Reviewer — Design Document

## Goal

Create a design reviewer system for the `dot-claude` plugin that reviews plans and code against DDD, hexagonal architecture, CQS, and OOP principles. The system separates the knowledge base (principles) from the review behavior (agents) so new reviewer types can be added easily.

## Architecture

Three components:

1. **Knowledge base skill** (`design-principles.md`) — shared principles, rules, and examples
2. **Plan reviewer agent** (`design-plan-reviewer.md`) — reviews design docs and plans
3. **Code reviewer agent** (`design-code-reviewer.md`) — reviews existing code

Both agents run as **subagents** (spawned via Task tool) to preserve the main context window. Both are **read-only** — they identify violations but do not apply fixes.

## File Structure

```
selrahcd-dot-claude/
  skills/
    design-principles.md
  agents/
    design-plan-reviewer.md
    design-code-reviewer.md
  commands/
    review-design.md
    review-code.md
```

## Knowledge Base Skill: `design-principles.md`

A skill file containing all reviewable principles. Agents load this skill to get the shared rule set.

### Principles

#### Command Query Separation

- A method either changes state (command) or returns a result (query), never both
- Commands return void
- Queries have no side effects
- Violation example: `placeOrder()` returns the created order — split into a command `placeOrder()` and a query `getOrder()`

#### Hexagonal Architecture

- Domain at the center, no dependency on infrastructure
- Ports are interfaces defined by the domain; adapters implement them in the infrastructure layer
- Dependency rule: outer layers depend on inner, never the reverse
- No framework annotations, decorators, or imports in domain code
- Application layer orchestrates use cases by calling domain and ports

#### DDD Tactical Patterns

- **Aggregates**: protect invariants, define the consistency boundary, accessed only through the aggregate root
- **Value Objects**: immutable, compared by value, carry behavior relevant to what they represent (e.g., `Email.validate()`, `Money.add()`)
- **Entities**: identity-based, state changes through explicit methods that enforce invariants
- **Domain Events**: named in past tense using ubiquitous language (`OrderShipped`, not `OrderEvent` or `OrderUpdated`)
- **Repositories**: one per aggregate root, interface defined in the domain, implementation in infrastructure

#### DDD Strategic Patterns

- Bounded contexts with explicit boundaries — no sharing of internal models across contexts
- Ubiquitous language: code uses domain terms, not technical jargon
- Context mapping when integrating between contexts (anti-corruption layer, shared kernel, published language)

#### Identity

- IDs are UUIDs generated by the caller or the domain, not auto-incremented by the database
- Enables creating aggregates without a round-trip to persistence
- IDs should be value objects (typed, not raw strings or numbers)

#### Naming

- Use domain language everywhere: class names, method names, variable names
- Avoid generic or meaningless words: `data`, `service`, `manager`, `handler`, `helper`, `utils`, `processor`, `info`, `item`
- Name classes and methods after what they represent in the domain
- If you cannot name something using domain language, the model is likely wrong

#### OOP Discipline

- No helper or utility classes — behavior belongs on the object that owns the data
- No anemic models — entities and value objects carry behavior, not just getters and setters
- Tell, don't ask — send messages to objects rather than extracting data and acting on it externally
- Favor small, focused classes over large classes with many responsibilities

## Agent: `design-plan-reviewer.md`

**Purpose:** Reviews design documents and implementation plans against the principles.

**Runs as:** Subagent (spawned via Task tool, preserves main context)

**Tools:** `Read`, `Glob`, `Grep` (read-only)

**Workflow:**

1. Load the `design-principles` skill
2. Read the project's `CLAUDE.md` for project-specific conventions
3. Read the target plan or design document
4. Review every section against each principle and CLAUDE.md rules
5. Produce a structured violation report
6. Return the report to the main context

**Output format:**

```
## Design Review: <filename>

### Violations

1. **<Principle>** — <Section or quote from the plan> — <Why this violates the principle>

### Verdict: PASS | FAIL (<N> violations)
```

**Behavior:**

- Strict gatekeeper: every violation is reported, none are optional
- Does NOT propose fixes — only identifies violations
- If no violations found, returns PASS

## Agent: `design-code-reviewer.md`

**Purpose:** Reviews existing code against the principles and proposes improvements.

**Runs as:** Subagent (spawned via Task tool, preserves main context)

**Tools:** `Read`, `Glob`, `Grep` (read-only)

**Workflow:**

1. Load the `design-principles` skill
2. Read the project's `CLAUDE.md` for project-specific conventions
3. Read the target file(s) and explore related code (imports, interfaces, types, tests)
4. Scan for violations of each principle and CLAUDE.md rules
5. Produce a structured violation report
6. Return the report to the main context

**Output format:**

```
## Code Review: <path>

### Violations

1. **<Principle>** — `<file>:<line>` — <What the code does> — <Why this violates the principle>

### Verdict: PASS | FAIL (<N> violations)
```

**Behavior:**

- Strict gatekeeper: every violation is reported
- Does NOT apply fixes — read-only analysis only
- Follows imports and reads related files to understand context (e.g., checks if a "service" class exists because behavior was extracted from the domain)

## Commands

### `/review-design <path>`

Triggers the `design-plan-reviewer` agent as a subagent with the given path.

### `/review-code <path>`

Triggers the `design-code-reviewer` agent as a subagent with the given path.

## Examples

### Plan review catching CQS violation

```
## Design Review: docs/plans/2026-02-26-order-system-design.md

### Violations

1. **CQS** — Section "Order Creation" describes `placeOrder()` as returning
   the created order. A command must not return data. Separate into a command
   that places the order and a query that retrieves it.

2. **Naming** — "OrderProcessingService" uses generic words "Processing" and
   "Service". Name after what it does in the domain.

3. **Identity** — No mention of how Order IDs are generated. Design should
   specify client-side UUID generation.

### Verdict: FAIL (3 violations)
```

### Code review catching anemic model

```
## Code Review: src/order/

### Violations

1. **OOP / Anemic model** — `src/order/Order.ts:15` — Order is a plain data
   class with only getters. Validation and state transitions live in
   `src/order/OrderService.ts`. Behavior belongs on the aggregate.

2. **Hexagonal** — `src/order/Order.ts:3` — Imports `TypeORM` decorator.
   Domain must not depend on infrastructure.

3. **Naming** — `src/order/OrderHelper.ts` — Helper class. Behavior should
   live on the object that owns the data.

4. **CQS** — `src/order/OrderRepository.ts:22` — `save()` returns the saved
   entity. Commands must return void.

5. **Identity** — `src/order/Order.ts:8` — ID is `number` (auto-increment).
   Should be a UUID value object generated by the domain.

### Verdict: FAIL (5 violations)
```

## Extensibility

Adding a new reviewer type (e.g., PR reviewer, test reviewer) requires:

1. A new agent file in `agents/` that loads the same `design-principles` skill
2. A new command file in `commands/` to trigger it
3. No changes to the knowledge base unless new principles are needed
