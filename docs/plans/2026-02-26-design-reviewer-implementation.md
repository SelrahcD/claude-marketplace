# Design Reviewer Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a design reviewer system to the `dot-claude` plugin — a shared knowledge base skill and two subagent-based reviewers (plan and code).

**Architecture:** One skill file (`design-principles.md`) holds the principles. Two agents (`design-plan-reviewer.md`, `design-code-reviewer.md`) load the skill and CLAUDE.md, then produce structured violation reports. Two commands (`review-design.md`, `review-code.md`) trigger them.

**Tech Stack:** Claude Code plugin system (markdown skills, agents, commands)

---

### Task 1: Create the knowledge base skill

**Files:**
- Create: `selrahcd-dot-claude/skills/design-principles.md`

**Step 1: Create the skill file**

```markdown
---
name: design-principles
description: Knowledge base of design principles for reviewing plans and code — CQS, hexagonal architecture, DDD, naming, OOP discipline
---

# Design Principles — Knowledge Base

Use these principles when reviewing plans or code. Each principle includes rules and violation examples.

## Command Query Separation (CQS)

**Rules:**
- A method either changes state (command) or returns a result (query), never both
- Commands return void
- Queries have no side effects
- Factory methods are an exception: they create and return a new object without modifying existing state

**Violation examples:**
- `placeOrder()` returns the created order — split into command `placeOrder(orderId)` and query `getOrder(orderId)`
- `withdraw(amount)` returns the new balance — the command should return void, query the balance separately
- A repository `save()` that returns the saved entity — `save()` should return void

## Hexagonal Architecture

**Rules:**
- Domain is at the center, with zero dependencies on infrastructure or frameworks
- Ports are interfaces defined by the domain — they express what the domain needs
- Adapters live in the infrastructure layer and implement ports
- Dependency rule: outer layers depend on inner layers, never the reverse
- No framework annotations, decorators, or imports in domain code
- Application layer orchestrates use cases by calling domain objects and ports
- Tests should be able to run without any infrastructure (database, HTTP, filesystem)

**Violation examples:**
- Domain entity imports a TypeORM decorator or a Prisma type
- A use case directly instantiates a database client instead of going through a port
- Domain code imports from an `infrastructure/` or `adapters/` directory
- A controller contains business logic instead of delegating to the application layer

## DDD Tactical Patterns

### Aggregates
- Protect invariants — all state changes go through methods that enforce business rules
- Define the consistency boundary — one transaction per aggregate
- Accessed only through the aggregate root — never reach into child entities directly
- Keep aggregates small — prefer references by ID over direct object references to other aggregates

### Value Objects
- Immutable — once created, they never change
- Compared by value, not by reference
- Carry behavior relevant to what they represent (e.g., `Email.validate()`, `Money.add(other)`)
- Use them for any concept with no lifecycle identity: amounts, addresses, date ranges, measurements

### Entities
- Identity-based — two entities with the same data but different IDs are different
- State changes through explicit methods that enforce invariants
- Never expose setters that bypass business rules

### Domain Events
- Named in past tense using ubiquitous language: `OrderShipped`, `PaymentReceived`
- Not vague: avoid `OrderUpdated`, `OrderEvent`, `OrderChanged`
- Carry the data needed by consumers, nothing more

### Repositories
- One per aggregate root
- Interface defined in the domain layer
- Implementation in the infrastructure layer
- Should not expose query-builder or ORM-specific APIs

## DDD Strategic Patterns

**Rules:**
- Bounded contexts have explicit boundaries — no sharing of internal models across contexts
- Ubiquitous language: code uses domain terms, not technical jargon
- Context mapping when integrating between contexts: anti-corruption layer, shared kernel, published language
- Different contexts may have different models for the same real-world concept — that is intentional, not duplication

**Violation examples:**
- Two modules share the same `User` entity with fields relevant to only one context
- A module reaches into another module's database tables or internal classes
- Domain code uses generic technical terms instead of domain-specific vocabulary

## Identity

**Rules:**
- IDs are UUIDs generated by the caller or the domain, never auto-incremented by the database
- This enables creating aggregates without a round-trip to persistence
- IDs should be value objects — typed, not raw strings or numbers
- The creator of an aggregate decides its ID at construction time

**Violation examples:**
- Entity ID is `number` or `autoincrement`
- A `create` method does not accept an ID parameter and relies on the DB to assign one
- ID is a plain `string` instead of a dedicated type like `OrderId`

## Naming

**Rules:**
- Use domain language everywhere: class names, method names, variable names, module names
- Avoid generic or meaningless words: `data`, `service`, `manager`, `handler`, `helper`, `utils`, `processor`, `info`, `item`, `stuff`, `object`, `thing`
- Name classes and methods after what they represent or do in the domain
- If you cannot name something using domain language, the model is likely wrong — rethink the design
- Method names should express intent: `ship()` not `updateStatus()`

**Violation examples:**
- `OrderService` — what does it do in the domain? Name it after its responsibility
- `DataProcessor` — "data" and "processor" are both meaningless
- `UserHelper` — helpers are a code smell, behavior belongs on the object
- `handleOrder()` — "handle" says nothing about what happens to the order
- `OrderInfo`, `OrderData` — just name it after what it actually is

## OOP Discipline

**Rules:**
- No helper or utility classes — behavior belongs on the object that owns the data
- No anemic models — entities and value objects carry behavior, not just getters and setters
- Tell, don't ask — send messages to objects rather than extracting their data and acting on it externally
- Favor small, focused classes over large classes with many responsibilities
- Encapsulation: objects hide their internals and expose behavior

**Violation examples:**
- `OrderHelper.calculateTotal(order)` — `calculateTotal()` belongs on `Order`
- An entity that is a bag of getters/setters with all logic in a separate "service"
- Code that does `if (order.getStatus() === 'shipped') { ... }` instead of `order.ship()` or `order.isShipped()`
- A `StringUtils` class — if you need string behavior, create a value object
```

**Step 2: Verify the file was created**

Run: `cat -n selrahcd-dot-claude/skills/design-principles.md | head -5`
Expected: file exists with YAML frontmatter starting with `---`

**Step 3: Commit**

```bash
git add selrahcd-dot-claude/skills/design-principles.md
git commit -m "feat(dot-claude): add design-principles knowledge base skill"
```

---

### Task 2: Create the plan reviewer agent

**Files:**
- Create: `selrahcd-dot-claude/agents/design-plan-reviewer.md`

**Step 1: Create the agent file**

```markdown
---
name: design-plan-reviewer
description: "Reviews design documents and implementation plans against design principles (CQS, hexagonal, DDD, naming, OOP). Strict gatekeeper — reports every violation. Use when reviewing a plan or design doc."
tools: Read, Glob, Grep
---

You are a strict design reviewer. Your job is to review a design document or implementation plan against established design principles and report every violation.

## Setup

1. Use the `design-principles` skill — it contains all the principles you review against
2. Find and read the project's `CLAUDE.md` file (check the working directory root). It contains project-specific conventions that also apply
3. Read the target document provided in the prompt

## Review Process

Go through the document section by section. For each section, check against every principle in the knowledge base and every relevant rule in CLAUDE.md.

Look for:
- Explicit violations: the plan describes something that breaks a principle
- Missing concerns: the plan omits something a principle requires (e.g., no mention of how IDs are generated)
- Naming issues: generic or technical words where domain language should be used
- Architecture violations: wrong dependency direction, domain depending on infrastructure
- CQS violations: methods that both change state and return results
- Anemic models: behavior described as living outside the entity/aggregate
- Missing invariant protection: state changes that bypass the aggregate

## Output Format

Produce exactly this format:

```
## Design Review: <filename>

### Violations

1. **<Principle>** — <Section or quote from the plan> — <Why this violates the principle>

(repeat for each violation)

### Verdict: PASS | FAIL (<N> violations)
```

If there are no violations, output:

```
## Design Review: <filename>

### Violations

None.

### Verdict: PASS
```

## Rules

- Report EVERY violation. No "nice to have" or "consider this" — every issue is a violation that must be addressed
- Do NOT propose fixes. Only identify what is wrong and which principle it violates
- Do NOT soften language. State violations directly
- If something is ambiguous in the plan, flag it as a violation — ambiguity in design leads to bugs
- Review the ENTIRE document, do not stop early
```

**Step 2: Verify the file was created**

Run: `cat -n selrahcd-dot-claude/agents/design-plan-reviewer.md | head -5`
Expected: file exists with YAML frontmatter

**Step 3: Commit**

```bash
git add selrahcd-dot-claude/agents/design-plan-reviewer.md
git commit -m "feat(dot-claude): add design plan reviewer agent"
```

---

### Task 3: Create the code reviewer agent

**Files:**
- Create: `selrahcd-dot-claude/agents/design-code-reviewer.md`

**Step 1: Create the agent file**

```markdown
---
name: design-code-reviewer
description: "Reviews existing code against design principles (CQS, hexagonal, DDD, naming, OOP). Strict gatekeeper — reports every violation with file and line references. Use when reviewing code for design quality."
tools: Read, Glob, Grep
---

You are a strict design code reviewer. Your job is to review existing code against established design principles and report every violation with precise file and line references.

## Setup

1. Use the `design-principles` skill — it contains all the principles you review against
2. Find and read the project's `CLAUDE.md` file (check the working directory root). It contains project-specific conventions that also apply
3. Read the target file(s) or directory provided in the prompt
4. Follow imports and read related files (interfaces, types, tests, other classes in the same module) to understand context

## Review Process

For each file, scan the code against every principle in the knowledge base and every relevant rule in CLAUDE.md.

Look for:
- **CQS violations**: methods that both mutate state and return a value
- **Hexagonal violations**: domain code importing from infrastructure, framework annotations in domain, wrong dependency direction
- **Anemic models**: entities/aggregates that are data bags with logic living in separate classes
- **Missing value objects**: primitive obsession — raw strings/numbers used where a typed value object should exist
- **Naming violations**: generic words (`service`, `handler`, `helper`, `manager`, `data`, `utils`, `processor`), technical jargon where domain language should be used
- **Identity violations**: auto-increment IDs, IDs as raw primitives, IDs generated by the database
- **Helper/utility classes**: behavior that should live on the object that owns the data
- **Tell don't ask violations**: code that extracts data from objects to act on it externally instead of sending a message
- **Aggregate boundary violations**: reaching into child entities, transactions spanning multiple aggregates
- **Missing invariant enforcement**: setters or public mutation without business rule checks
- **Bounded context leaks**: internal models shared across module boundaries

## Output Format

Produce exactly this format:

```
## Code Review: <path>

### Violations

1. **<Principle>** — `<file>:<line>` — <What the code does> — <Why this violates the principle>

(repeat for each violation)

### Verdict: PASS | FAIL (<N> violations)
```

If there are no violations, output:

```
## Code Review: <path>

### Violations

None.

### Verdict: PASS
```

## Rules

- Report EVERY violation. No "nice to have" or "consider this" — every issue is a violation that must be addressed
- Do NOT propose fixes or refactored code. Only identify what is wrong
- Do NOT soften language. State violations directly
- Always include the exact file path and line number
- Read related files to understand context before flagging — a "service" class might exist for a valid reason (application layer orchestration), or it might be an anemic model symptom
- Review ALL files in scope, do not stop early
```

**Step 2: Verify the file was created**

Run: `cat -n selrahcd-dot-claude/agents/design-code-reviewer.md | head -5`
Expected: file exists with YAML frontmatter

**Step 3: Commit**

```bash
git add selrahcd-dot-claude/agents/design-code-reviewer.md
git commit -m "feat(dot-claude): add design code reviewer agent"
```

---

### Task 4: Create the review-design command

**Files:**
- Create: `selrahcd-dot-claude/commands/review-design.md`

**Step 1: Create the command file**

```markdown
---
name: review-design
description: Review a design document or plan against design principles (CQS, hexagonal, DDD, naming, OOP)
---

# Review Design

Review the provided design document against design principles.

## Usage

```
/review-design <path-to-design-doc>
```

## Steps

1. Spawn the `design-plan-reviewer` agent as a subagent with the following prompt:

> Review the design document at `<path>` against all design principles. Report every violation.

2. Display the agent's violation report to the user
```

**Step 2: Verify**

Run: `cat -n selrahcd-dot-claude/commands/review-design.md | head -5`
Expected: file exists with YAML frontmatter

**Step 3: Commit**

```bash
git add selrahcd-dot-claude/commands/review-design.md
git commit -m "feat(dot-claude): add review-design command"
```

---

### Task 5: Create the review-code command

**Files:**
- Create: `selrahcd-dot-claude/commands/review-code.md`

**Step 1: Create the command file**

```markdown
---
name: review-code
description: Review existing code against design principles (CQS, hexagonal, DDD, naming, OOP)
---

# Review Code

Review the provided code against design principles.

## Usage

```
/review-code <path-to-code>
```

## Steps

1. Spawn the `design-code-reviewer` agent as a subagent with the following prompt:

> Review the code at `<path>` against all design principles. Report every violation.

2. Display the agent's violation report to the user
```

**Step 2: Verify**

Run: `cat -n selrahcd-dot-claude/commands/review-code.md | head -5`
Expected: file exists with YAML frontmatter

**Step 3: Commit**

```bash
git add selrahcd-dot-claude/commands/review-code.md
git commit -m "feat(dot-claude): add review-code command"
```

---

### Task 6: Bump plugin version

**Files:**
- Modify: `selrahcd-dot-claude/.claude-plugin/plugin.json`
- Modify: `.claude-plugin/marketplace.json`

**Step 1: Update plugin.json version**

In `selrahcd-dot-claude/.claude-plugin/plugin.json`, change `"version": "1.21.0"` to `"version": "1.22.0"`.

**Step 2: Update marketplace.json version**

In `.claude-plugin/marketplace.json`, change the `dot-claude` entry version from `"1.21.0"` to `"1.22.0"`.

**Step 3: Verify both files match**

Run: `grep -n "version" selrahcd-dot-claude/.claude-plugin/plugin.json .claude-plugin/marketplace.json`
Expected: both show `1.22.0` for dot-claude

**Step 4: Commit**

```bash
git add selrahcd-dot-claude/.claude-plugin/plugin.json .claude-plugin/marketplace.json
git commit -m "chore(dot-claude): bump version to 1.22.0"
```

---

### Task 7: Manual verification

**Step 1: Verify file structure**

Run: `find selrahcd-dot-claude/skills selrahcd-dot-claude/agents selrahcd-dot-claude/commands -name "*.md" | sort`

Expected:
```
selrahcd-dot-claude/agents/commit-assistant.md
selrahcd-dot-claude/agents/design-code-reviewer.md
selrahcd-dot-claude/agents/design-plan-reviewer.md
selrahcd-dot-claude/commands/bugmagnet.md
selrahcd-dot-claude/commands/commit-push.md
selrahcd-dot-claude/commands/commit.md
selrahcd-dot-claude/commands/create-pr.md
selrahcd-dot-claude/commands/handle-pr-review.md
selrahcd-dot-claude/commands/review-code.md
selrahcd-dot-claude/commands/review-design.md
selrahcd-dot-claude/skills/design-principles.md
```

**Step 2: Verify all commits landed**

Run: `git log --oneline -6`

Expected: 6 new commits (knowledge base, plan reviewer, code reviewer, review-design command, review-code command, version bump)
